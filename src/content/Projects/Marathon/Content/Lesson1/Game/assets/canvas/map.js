
// -- user code here --

/* --- start generated code --- */

// Generated by Phaser Editor v1.4.1 (Phaser v2.6.2)


/**
 * Map.
 */
function Map() {
	
	Phaser.State.call(this);
	
}

/** @type Phaser.State */
var Map_proto = Object.create(Phaser.State.prototype);
Map.prototype = Map_proto;
Map.prototype.constructor = Map;

Map.prototype.init = function () {
	
	this.initCustom();
	
};

Map.prototype.preload = function () {
	
	this.load.pack('sprites', 'assets/pack.json');
	this.load.pack('maps', 'assets/pack.json');
	
};

Map.prototype.create = function () {
	var _water_sprite = this.add.tileSprite(0, 0, 1280, 720, 'water_sprite', 0);
	var _water_sprite_default = _water_sprite.animations.add('default', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], 24, true);
	_water_sprite_default.play();
	
	this.add.sprite(0, 0, 'mapOverlay');
	
	this.add.sprite(179, -186, 'map_pipes');
	
	var _levels = this.add.sprite(129, 103, 'levels');
	_levels.alpha = 0.0;
	
	var _props = this.add.group();
	
	var _bulldozer_sprite = new bulldozer(this.game, 1023, 154);
	_props.add(_bulldozer_sprite);
	
	var _oilPump_sprite = new oilPump(this.game, 32, 183);
	_props.add(_oilPump_sprite);
	
	var _windmill_sprite = new windmill_small(this.game, 706, 18);
	_props.add(_windmill_sprite);
	
	var _nodes = this.add.group();
	_nodes.alpha = 0.0;
	
	var _collider = this.add.sprite(624, 170, 'collider', 0, _nodes);
	_collider.name = 'node1';
	
	this.add.sprite(195, 170, 'collider', 0, _nodes);
	
	this.add.sprite(195, 539, 'collider', 0, _nodes);
	
	this.add.sprite(624, 539, 'collider', 0, _nodes);
	
	this.add.sprite(624, 360, 'collider', 0, _nodes);
	
	this.add.sprite(1134, 360, 'collider', 0, _nodes);
	
	this.add.sprite(129, 103, 'levelsBackground');
	
	var _stop1 = this.add.sprite(129, 103, 'stop1');
	_stop1.name = 'stop1';
	
	var _stop2 = this.add.sprite(129, 103, 'stop2');
	_stop2.name = 'stop2';
	
	var _stop3 = this.add.sprite(129, 103, 'stop3');
	_stop3.name = 'stop3';
	
	var _stop4 = this.add.sprite(129, 103, 'stop4');
	_stop4.name = 'stop4';
	
	var _stop5 = this.add.sprite(129, 103, 'stop5');
	_stop5.name = 'stop5';
	
	var _mike = new mike_map(this.game, 624, 164);
	this.add.existing(_mike);
	
	this.add.sprite(873, -1, 'map_instructions');
	
	// public fields
	
	this.fNodes = _nodes;
	this.fStop1 = _stop1;
	this.fStop2 = _stop2;
	this.fStop3 = _stop3;
	this.fStop4 = _stop4;
	this.fStop5 = _stop5;
	this.fMike = _mike;
	this.createCustom();
	
};

/* --- end generated code --- */
// -- user code here --

var isInShell = parent && 'Shell' in parent;
var Shell = isInShell ? parent.Shell : undefined;

var nodes = [];
var currentNode = 0;
var isMoving = false;


Map.prototype.update = function() {
	
		//this.fMike.x = this.fNodes.children[2].position.x;
		//this.fMike.y = this.fNodes.children[2].position.x;
		
		
	if(!isMoving) {
		this.fMike.animations.play('idle');
		
		if(this.cursors.left.isDown && 'left' in nodes[currentNode] || this.leftArrow.isDown && 'left' in nodes[currentNode]) {
			// Check if the destination slide is unlocked
			if(!nodes[nodes[currentNode].left.id].unlocked())
				return;
			
			// Set moving flag so we don't repeat this code.
			isMoving = true;
			
			// Animate and change directions
			this.fMike.animations.play('walk');
			this.fMike.scale.x = -0.5;
			
			// Start the tween to the next node.
			nodes[currentNode].left.tween.start();
			
			// Set the current node to the next node.
			currentNode = nodes[currentNode].left.id;
			
			XMLog('currentNode: ' + currentNode);
		} else if(this.cursors.right.isDown && 'right' in nodes[currentNode] || this.rightArrow.isDown && 'right' in nodes[currentNode]) {
			if(!nodes[nodes[currentNode].right.id].unlocked())
				return;
			
			isMoving = true;
			this.fMike.animations.play('walk');
			this.fMike.scale.x = 0.5;
			nodes[currentNode].right.tween.start();
			currentNode = nodes[currentNode].right.id;
		} else if(this.cursors.down.isDown && 'down' in nodes[currentNode] || this.downArrow.isDown && 'down' in nodes[currentNode]) {
			if(!nodes[nodes[currentNode].down.id].unlocked())
				return;
			
			isMoving = true;
			this.fMike.animations.play('walk');
			this.fMike.scale.x = -0.5;
			nodes[currentNode].down.tween.start();
			currentNode = nodes[currentNode].down.id;
		} else if(this.cursors.up.isDown && 'up' in nodes[currentNode] || this.upArrow.isDown && 'up' in nodes[currentNode]) {
			if(!nodes[nodes[currentNode].up.id].unlocked())
				return;
						
			isMoving = true;
			this.fMike.animations.play('walk');
			this.fMike.scale.x = 0.5;
			nodes[currentNode].up.tween.start();
			currentNode = nodes[currentNode].up.id;
		} else if(this.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR) || this.jumpbutton.isDown) {
			// Set moving so we only call this code once, then navigate to the destination.
			isMoving = true;
			nodes[currentNode].callback();
		}
	}
	

};

Map.prototype.initCustom = function() {
	if(isInShell) {
		Shell.BindCustomSlide(this);
		Shell.OnCustomSlideLoaded();
	}
};

Map.prototype.createCustom = function() {
	// Tweens to map nodes
	var tween0 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[0].position.x,
		y: this.fNodes.children[0].position.y
	}, 600);
	tween0.onComplete.add(function() {
		isMoving = false;
	});

	var tween1 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[1].position.x,
		y: this.fNodes.children[1].position.y
	}, 600);
	tween1.onComplete.add(function() {
		isMoving = false;
	});

	var tween2 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[2].position.x,
		y: this.fNodes.children[2].position.y
	}, 600);
	tween2.onComplete.add(function() {
		isMoving = false;
	});

	var tween3 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[3].position.x,
		y: this.fNodes.children[3].position.y
	}, 600);
	tween3.onComplete.add(function() {
		isMoving = false;
	});
	
	var tween3From4 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[3].position.x,
		y: this.fNodes.children[3].position.y
	}, 300);
	tween3From4.onComplete.add(function() {
		isMoving = false;
	});

	var tween5 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[5].position.x,
		y: this.fNodes.children[5].position.y
	}, 600);
	tween5.onComplete.add(function() {
		isMoving = false;
	});

	var tween4 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[4].position.x,
		y: this.fNodes.children[4].position.y
	}, 300);
	tween4.onComplete.add(function() {
		tween5.start();
	});

	var tween4From5 = this.game.add.tween(this.fMike).to({
		x: this.fNodes.children[4].position.x,
		y: this.fNodes.children[4].position.y
	}, 600);
	tween4From5.onComplete.add(function() {
		tween3From4.start();
	});
		
	// Map Nodes
	nodes.push({
		node: this.fNodes.children[0],
		unlocked: function() { return true; },
		left: { tween: tween1, id: 1 },
		callback: function() {
			if(isInShell)
				Shell.GoToSlide(3);
		}
	});
	
	nodes.push({
		node: this.fNodes.children[1],
		unlocked: function() {return isInShell ? Shell.isSlideUnlocked(4) : true; },
		right: { tween: tween0, id: 0 },
		down: { tween: tween2, id: 2 },
		callback: function() {
			if(isInShell)
				Shell.GoToSlide(4);
		}
	});
	
	nodes.push({
		node: this.fNodes.children[2],
		unlocked: function() {return isInShell ? Shell.isSlideUnlocked(5) : true; },
		right: { tween: tween3, id: 3 },
		up: { tween: tween1, id: 1 },
		callback: function() {
			if(isInShell)
				Shell.GoToSlide(5);
		}
	});
	
	nodes.push({
		node: this.fNodes.children[3],
		unlocked: function() {return isInShell ? Shell.isSlideUnlocked(6) : true; },
		up: { tween: tween4, id: 4 },
		right: { tween: tween4, id: 4 },
		left: { tween: tween2, id: 2 },
		callback: function() {
			if(isInShell)
				Shell.GoToSlide(6);
		}
	});
	
	nodes.push({
		node: this.fNodes.children[5],
		unlocked: function() {return isInShell ? Shell.isSlideUnlocked(7) : true; },
		down: { tween: tween4From5, id: 3 },
		left: { tween: tween4From5, id: 3 },
		callback: function() {
			if(isInShell)
				Shell.GoToSlide(7);
		}
		
		

	});
	
	this.fStop2.alpha = .5;
	this.fStop3.alpha = .5;
	this.fStop4.alpha = .5;
	this.fStop5.alpha = .5;
	
	if (Shell.isSlideUnlocked(4)) {
		this.fStop2.alpha = 1;
		currentNode = 0;
		
	}
	
	if (Shell.isSlideUnlocked(5)) {
			this.fStop3.alpha = 1;
			this.fMike.x = 195;
			this.fMike.y = 170;
			currentNode = 1;
		}
	
	if (Shell.isSlideUnlocked(6)) {
			this.fStop4.alpha = 1;
			this.fMike.x = 195;
			this.fMike.y = 539;
			currentNode = 2;
		}
	
	if (Shell.isSlideUnlocked(7)) {
			this.fStop5.alpha = 1;
			this.fMike.x = 624;
			this.fMike.y = 539;
			currentNode = 3;
		}
	

	// Input
	this.cursors = this.input.keyboard.createCursorKeys();
	
	this.pad = this.game.plugins.add(Phaser.VirtualJoystick);
	this.thing = this.pad.addButton();
	
	this.leftArrow = this.pad.addButton(1035, 566, 'left_arrow', 'left_arrow-up', 'left_arrow-down');
	this.leftArrow.addKey(Phaser.KeyCode.LEFT);
	
	this.rightArrow = this.pad.addButton(1169, 566, 'right_arrow', 'right_arrow-up', 'right_arrow-down');
	this.rightArrow.addKey(Phaser.KeyCode.RIGHT);
	
	this.downArrow = this.pad.addButton(1103, 633, 'down_arrow', 'down_arrow-up', 'down_arrow-down');
	this.downArrow.addKey(Phaser.KeyCode.DOWN);
	
	this.upArrow = this.pad.addButton(1103, 499, 'up_arrow', 'up_arrow-up', 'up_arrow-down');
	this.upArrow.addKey(Phaser.KeyCode.UP);
	
	this.jumpbutton = this.pad.addButton(1103, 566, 'jump_button', 'jump_button-up', 'jump_button-down');
	this.jumpbutton.addKey(Phaser.KeyCode.SPACEBAR);
};